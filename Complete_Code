#include <NewPing.h>

// Define the PIR sensor pins
const int pirSensor1 = 35;  // PIR sensor 1 at front-left corner
const int pirSensor2 = 34;  // PIR sensor 2 at front-right corner

// Define a variable to track the motion state
bool motionDetected = false;

// Timing variables
unsigned long motionTime = 0;  // Store time when motion is detected
const unsigned long taskDuration = 10000; // 10 seconds for other tasks

// Debounce timing
unsigned long debounceTime = 0;
const unsigned long debounceDelay = 1000; // 1 second debounce time

// ========== HARDWARE CONFIGURATION ==========
// Motor and sensor setup (same as original code)
constexpr uint8_t MOTOR_PINS[4]  = {22, 23, 24, 25};   // IN1, IN2, IN3, IN4 (L293D)
constexpr uint8_t US_PINS[3][2]  = {{30,31}, {28,29}, {32,33}}; // Left, Front, Right
constexpr uint8_t IR_PINS[2]     = {26, 27};           // Left, Right
constexpr uint16_t MAX_DISTANCE  = 200;               // cm

// ========== SAFETY CONSTANTS ==========
// Same constants from the original code
constexpr uint16_t OBSTACLE_DISTANCE = 30;   // cm, “too close”
constexpr uint16_t TURNING_DISTANCE  = 40;   // cm, “allow turn”
constexpr uint16_t REVERSE_TIME      = 300;  // ms
constexpr uint16_t TURN_TIME         = 500;  // ms
constexpr uint16_t SAMPLE_INTERVAL   = 50;   // ms

// ========== MOTOR CONTROLLER ==========
// Same MotorController class as the original code

class MotorController {
  const uint8_t* pins;
  uint8_t state = 0;

  void apply() {
    for (uint8_t i = 0; i < 4; ++i) {
      digitalWrite(pins[i], (state & (0b1000 >> i)) ? HIGH : LOW);
    }
  }

public:
  MotorController(const uint8_t mp[4])
    : pins(mp)
  {
    for (uint8_t i = 0; i < 4; ++i) {
      pinMode(pins[i], OUTPUT);
    }
    stop();
  }

  void forward()  { state = 0b0110; apply(); }
  void backward() { state = 0b1001; apply(); }
  void turnLeft() { state = 0b0010; apply(); }
  void turnRight(){ state = 0b0100; apply(); }
  void stop()     { state = 0b0000; apply(); }
};

// ========== SENSOR ARRAY ==========
// Same SensorArray class as the original code

class SensorArray {
  NewPing sonar[3];
  uint8_t irPins[2];
  uint32_t lastSample = 0;
  float bufUS[3][5] = {};
  uint8_t idxUS = 0;

public:
  struct Data {
    uint16_t dist[3];  // distances: left, front, right
    bool     ir[2];    // IR sensors: left, right
  };

  SensorArray()
    : sonar{
        NewPing(US_PINS[0][0], US_PINS[0][1], MAX_DISTANCE),
        NewPing(US_PINS[1][0], US_PINS[1][1], MAX_DISTANCE),
        NewPing(US_PINS[2][0], US_PINS[2][1], MAX_DISTANCE)
      },
      irPins{ IR_PINS[0], IR_PINS[1] }
  {
    for (auto p : irPins) pinMode(p, INPUT);

    for (auto& sensor : bufUS)
      for (auto& val : sensor)
        val = MAX_DISTANCE;
  }

  Data read() {
    Data out = {};
    uint32_t now = millis();

    if (now - lastSample >= SAMPLE_INTERVAL) {
      lastSample = now;
      
      for (uint8_t s = 0; s < 3; s++) {
        auto r = sonar[s].ping_cm();
        bufUS[s][idxUS] = (r == 0) ? MAX_DISTANCE : r;
      }
      idxUS = (idxUS + 1) % 5;

      for (uint8_t i = 0; i < 2; i++) {
        bool a = (digitalRead(irPins[i]) == LOW);
        delay(1);
        bool b = (digitalRead(irPins[i]) == LOW);
        out.ir[i] = (a && b);
      }
    }

    for (uint8_t s = 0; s < 3; s++) {
      float sum = 0;
      for (auto v : bufUS[s]) sum += v;
      out.dist[s] = uint16_t(sum / 5.0);
    }

    return out;
  }
};

// ========== NAVIGATION CONTROLLER ==========
// Same NavigationSystem class as the original code

class NavigationSystem {
  MotorController& motors;
  SensorArray&     sensors;

  enum State { IDLE, MOVING, REV, AVOID };
  State st = IDLE;
  uint32_t actionTs = 0;

  bool safeAhead(uint16_t d) const { return d > OBSTACLE_DISTANCE; }
  bool canTurn(uint16_t d) const { return d > TURNING_DISTANCE; }

  void debugPrint(const char* msg) {
    Serial.println(msg);
  }

  void debugPrint(const __FlashStringHelper* msg) {
    Serial.println(msg);
  }

public:
  NavigationSystem(MotorController& m, SensorArray& s)
    : motors(m), sensors(s) {}

  void update() {
    auto D = sensors.read();
    uint32_t now = millis();

    switch (st) {
      case IDLE:
        if (!safeAhead(D.dist[1])) {
          st = REV;  actionTs = now; motors.backward();
          debugPrint(F(">>> IDLE → REVERSING"));
        } else {
          st = MOVING; actionTs = now; motors.forward();
          debugPrint(F(">>> IDLE → MOVING"));
        }
        break;

      case MOVING:
        if (!safeAhead(D.dist[1]) || D.ir[0] || D.ir[1]) {
          st = REV;  actionTs = now; motors.backward();
          debugPrint(F(">>> MOVING → REVERSING"));
        }
        break;

      case REV:
        if (now - actionTs >= REVERSE_TIME) {
          bool L = canTurn(D.dist[0]) && !D.ir[0];
          bool R = canTurn(D.dist[2]) && !D.ir[1];

          if (L && R) {
            if (D.dist[0] > D.dist[2]) {
              motors.turnLeft();
              debugPrint(F(">>> TURN LEFT (both OK)"));
            } else {
              motors.turnRight();
              debugPrint(F(">>> TURN RIGHT (both OK)"));
            }
          } else if (L) {
            motors.turnLeft();
            debugPrint(F(">>> TURN LEFT"));
          } else if (R) {
            motors.turnRight();
            debugPrint(F(">>> TURN RIGHT"));
          } else {
            st = REV; actionTs = now; motors.backward();
            debugPrint(F(">>> FULL REVERSE (no way to turn)"));
            break;
          }

          st = AVOID; actionTs = now;
        }
        break;

      case AVOID:
        if (now - actionTs >= TURN_TIME) {
          st = MOVING; actionTs = now; motors.forward();
          debugPrint(F(">>> AVOID → MOVING"));
        }
        break;
    }
  }
};

// ========== MAIN LOOP ==========

MotorController motors(MOTOR_PINS);
SensorArray sensors;
NavigationSystem nav(motors, sensors);

void setup() {
  Serial.begin(115200);
  pinMode(pirSensor1, INPUT);
  pinMode(pirSensor2, INPUT);
  delay(5000); // Allow 5 seconds for PIR sensors to settle
  Serial.println("System Ready");
}

void loop() {
  // PIR motion detection logic
  bool sensor1 = digitalRead(pirSensor1);
  bool sensor2 = digitalRead(pirSensor2);

  if (millis() - debounceTime > debounceDelay) {
    if (sensor1 == HIGH || sensor2 == HIGH) {
      if (!motionDetected) {
        motionDetected = true;
        motionTime = millis();  // Record the time of motion
        Serial.println("Motion detected! Starting movement.");
      }
    }
    debounceTime = millis();
  }

  // If motion was detected, perform movement for 10 seconds
  if (motionDetected && (millis() - motionTime < taskDuration)) {
    nav.update();  // Perform the movement logic
  } else if (motionDetected && (millis() - motionTime >= taskDuration)) {
    // After 10 seconds, stop movement and reset state
    motionDetected = false;
    Serial.println("10 seconds passed. Stopping movement.");
  }

  delay(100); // Small delay to give CPU a break
}
