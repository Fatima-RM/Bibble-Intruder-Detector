#include <Arduino.h>
#include <NewPing.h>

// ========== HARDWARE CONFIGURATION ========== 
constexpr uint8_t MOTOR_PINS[4]  = {22, 23, 24, 25};   // IN1, IN2, IN3, IN4 (L293D)
constexpr uint8_t US_PINS[3][2]  = {{30,31}, {28,29}, {32,33}}; // Left, Front, Right
constexpr uint8_t IR_PINS[2]     = {26, 27};           // Left, Right
constexpr uint8_t PIR_PINS[4]    = {34, 35, 36, 37};   // PIR sensors at corners
constexpr uint16_t MAX_DISTANCE  = 200;               // cm

// ========== SAFETY CONSTANTS ========== 
constexpr uint16_t OBSTACLE_DISTANCE = 30;   // cm, “too close”
constexpr uint16_t TURNING_DISTANCE  = 40;   // cm, “allow turn”
constexpr uint16_t REVERSE_TIME      = 300;  // ms
constexpr uint16_t TURN_TIME         = 500;  // ms
constexpr uint16_t SAMPLE_INTERVAL   = 50;   // ms

// ========== MOTOR CONTROLLER ========== 
class MotorController {
  const uint8_t* pins;
  uint8_t state = 0;

  void apply() {
    for (uint8_t i = 0; i < 4; ++i) {
      digitalWrite(pins[i], (state & (0b1000 >> i)) ? HIGH : LOW);
    }
  }

public:
  MotorController(const uint8_t mp[4])
    : pins(mp)
  {
    for (uint8_t i = 0; i < 4; ++i) {
      pinMode(pins[i], OUTPUT);
    }
    stop();
  }

  void forward()  { state = 0b0110; apply(); }
  void backward() { state = 0b1001; apply(); }
  void turnLeft() { state = 0b0010; apply(); }
  void turnRight(){ state = 0b0100; apply(); }
  void stop()     { state = 0b0000; apply(); }
};

// ========== SENSOR ARRAY ========== 
class SensorArray {
  NewPing sonar[3];
  uint8_t irPins[2];
  uint8_t pirPins[4];  // PIR sensor pins
  uint32_t lastSample = 0;
  float bufUS[3][5] = {};
  uint8_t idxUS = 0;

public:
  struct Data {
    uint16_t dist[3];  // distances: left, front, right
    bool     ir[2];    // IR sensors: left, right
    bool     pir[4];   // PIR sensors: 4 corners
  };

  SensorArray()
    : sonar{
        NewPing(US_PINS[0][0], US_PINS[0][1], MAX_DISTANCE),
        NewPing(US_PINS[1][0], US_PINS[1][1], MAX_DISTANCE),
        NewPing(US_PINS[2][0], US_PINS[2][1], MAX_DISTANCE)
      },
      irPins{ IR_PINS[0], IR_PINS[1] },
      pirPins{ PIR_PINS[0], PIR_PINS[1], PIR_PINS[2], PIR_PINS[3] }
  {
    for (auto p : irPins) pinMode(p, INPUT);
    for (auto p : pirPins) pinMode(p, INPUT);

    for (auto& sensor : bufUS)
      for (auto& val : sensor)
        val = MAX_DISTANCE;
  }

  Data read() {
    Data out = {};
    uint32_t now = millis();

    if (now - lastSample >= SAMPLE_INTERVAL) {
      lastSample = now;
      
      // Reading ultrasonic sensors
      for (uint8_t s = 0; s < 3; s++) {
        auto r = sonar[s].ping_cm();
        bufUS[s][idxUS] = (r == 0) ? MAX_DISTANCE : r;
      }
      idxUS = (idxUS + 1) % 5;

      // Reading IR sensors
      for (uint8_t i = 0; i < 2; i++) {
        bool a = (digitalRead(irPins[i]) == LOW);
        delay(1);
        bool b = (digitalRead(irPins[i]) == LOW);
        out.ir[i] = (a && b);
      }

      // Reading PIR sensors
      for (uint8_t i = 0; i < 4; i++) {
        out.pir[i] = (digitalRead(pirPins[i]) == HIGH);
      }
    }

    // Averaging ultrasonic sensor readings
    for (uint8_t s = 0; s < 3; s++) {
      float sum = 0;
      for (auto v : bufUS[s]) sum += v;
      out.dist[s] = uint16_t(sum / 5.0);
    }

    return out;
  }
};

// ========== NAVIGATION CONTROLLER ========== 
class NavigationSystem {
  MotorController& motors;
  SensorArray&     sensors;

  enum State { IDLE, MOVING, REV, AVOID };
  State st = IDLE;
  uint32_t actionTs = 0;

  bool safeAhead(uint16_t d) const { return d > OBSTACLE_DISTANCE; }
  bool canTurn(uint16_t d) const { return d > TURNING_DISTANCE; }

  // Overloaded debugPrint functions for both RAM and Flash strings
  void debugPrint(const char* msg) {
    Serial.println(msg);
  }

  void debugPrint(const __FlashStringHelper* msg) {
    Serial.println(msg);
  }

public:
  NavigationSystem(MotorController& m, SensorArray& s)
    : motors(m), sensors(s) {}

  void update() {
    auto D = sensors.read();
    uint32_t now = millis();

    // Initial stationary state
    if (st == IDLE) {
      bool motionDetected = false;
      for (int i = 0; i < 4; i++) {
        if (D.pir[i]) {
          motionDetected = true;
          break;
        }
      }

      if (motionDetected) {
        st = MOVING; actionTs = now; motors.forward();
        debugPrint(F(">>> STATIONARY → MOVING (Motion Detected)"));
      }
    }

    // Existing logic for navigation
    switch (st) {
      case MOVING:
        if (!safeAhead(D.dist[1]) || D.ir[0] || D.ir[1]) {
          st = REV;  actionTs = now; motors.backward();
          debugPrint(F(">>> MOVING → REVERSING"));
        }
        break;

      case REV:
        if (now - actionTs >= REVERSE_TIME) {
          bool L = canTurn(D.dist[0]) && !D.ir[0];
          bool R = canTurn(D.dist[2]) && !D.ir[1];

          if (L && R) {
            if (D.dist[0] > D.dist[2]) {
              motors.turnLeft();
              debugPrint(F(">>> TURN LEFT (both OK)"));
            } else {
              motors.turnRight();
              debugPrint(F(">>> TURN RIGHT (both OK)"));
            }
          } else if (L) {
            motors.turnLeft();
            debugPrint(F(">>> TURN LEFT"));
          } else if (R) {
            motors.turnRight();
            debugPrint(F(">>> TURN RIGHT"));
          } else {
            st = REV; actionTs = now; motors.backward();
            debugPrint(F(">>> FULL REVERSE (no way to turn)"));
            break;
          }

          st = AVOID; actionTs = now;
        }
        break;

      case AVOID:
        if (now - actionTs >= TURN_TIME) {
          st = MOVING; actionTs = now; motors.forward();
          debugPrint(F(">>> AVOID → MOVING"));
        }
        break;
    }
  }
};

// ========== GLOBAL OBJECTS ========== 
MotorController motors(MOTOR_PINS);
SensorArray     sensors;
NavigationSystem nav(motors, sensors);

void setup() {
  Serial.begin(115200);
  Serial.println(F(">> Robot System Ready!"));
}

void loop() {
  nav.update();
}
