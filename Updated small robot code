// MotionDetectionRobot.cpp
#include <iostream>
#include <bitset>
#include <wiringPi.h>
#include <string>
#include <unistd.h>
using namespace std;

#define PIR_FRONT 0
#define PIR_BACK 1
#define PIR_LEFT 2
#define PIR_RIGHT 3
#define TRIG 4
#define ECHO 5
#define MOTOR_L1 6
#define MOTOR_L2 7
#define MOTOR_R1 8
#define MOTOR_R2 9

// Base abstract class
class Sensor {
public:
    virtual void init() = 0;
    virtual bool detect() = 0;
    virtual ~Sensor() {}
};

class PIRSensor : public Sensor {
private:
    int pin;
public:
    PIRSensor(int p) : pin(p) {}
    void init() override {
        pinMode(pin, INPUT);
    }
    bool detect() override {
        return digitalRead(pin);
    }
};

class UltrasonicSensor : public Sensor {
private:
    int trig, echo;
public:
    UltrasonicSensor(int t, int e) : trig(t), echo(e) {}
    void init() override {
        pinMode(trig, OUTPUT);
        pinMode(echo, INPUT);
    }
    bool detect() override {
        digitalWrite(trig, LOW);
        delayMicroseconds(2);
        digitalWrite(trig, HIGH);
        delayMicroseconds(10);
        digitalWrite(trig, LOW);
        long duration = pulseIn(echo, HIGH);
        float distance = duration * 0.034 / 2;
        return distance < 20; // obstacle if < 20cm
    }
};

// Base class for motors with operator overloading
class Motor {
protected:
    int l1, l2, r1, r2;
public:
    Motor(int _l1, int _l2, int _r1, int _r2) : l1(_l1), l2(_l2), r1(_r1), r2(_r2) {}
    virtual void move() = 0;
    void stop() {
        digitalWrite(l1, LOW); digitalWrite(l2, LOW);
        digitalWrite(r1, LOW); digitalWrite(r2, LOW);
    }
    // Bit manipulation for status output
    void printStatusBits(bool front, bool back, bool left, bool right) {
        bitset<4> status((front << 3) | (back << 2) | (left << 1) | right);
        cout << "[Sensor Bits F-B-L-R]: " << status << endl;
    }
    // Operator overloading for demonstration
    bool operator==(const Motor& other) {
        return l1 == other.l1 && r2 == other.r2;
    }
};

class MoveForward : public Motor {
public:
    MoveForward(int a, int b, int c, int d) : Motor(a, b, c, d) {}
    void move() override {
        digitalWrite(l1, HIGH); digitalWrite(l2, LOW);
        digitalWrite(r1, HIGH); digitalWrite(r2, LOW);
        cout << "Moving Forward\n";
    }
};

class TurnLeft : public Motor {
public:
    TurnLeft(int a, int b, int c, int d) : Motor(a, b, c, d) {}
    void move() override {
        digitalWrite(l1, LOW); digitalWrite(l2, HIGH);
        digitalWrite(r1, HIGH); digitalWrite(r2, LOW);
        cout << "Turning Left\n";
    }
};

class TurnRight : public Motor {
public:
    TurnRight(int a, int b, int c, int d) : Motor(a, b, c, d) {}
    void move() override {
        digitalWrite(l1, HIGH); digitalWrite(l2, LOW);
        digitalWrite(r1, LOW); digitalWrite(r2, HIGH);
        cout << "Turning Right\n";
    }
};

class MotionController;

// Friend class example
class VoiceOutput {
    friend class MotionController;
private:
    void speak(const string& msg) {
        cout << "[Voice] " << msg << endl;
    }
};

// Hybrid class using all concepts
class MotionController : public MoveForward, public TurnLeft, public TurnRight {
private:
    PIRSensor pirFront, pirBack, pirLeft, pirRight;
    UltrasonicSensor ultrasonic;
    VoiceOutput voice;
public:
    MotionController() :
        MoveForward(MOTOR_L1, MOTOR_L2, MOTOR_R1, MOTOR_R2),
        TurnLeft(MOTOR_L1, MOTOR_L2, MOTOR_R1, MOTOR_R2),
        TurnRight(MOTOR_L1, MOTOR_L2, MOTOR_R1, MOTOR_R2),
        pirFront(PIR_FRONT), pirBack(PIR_BACK), pirLeft(PIR_LEFT), pirRight(PIR_RIGHT),
        ultrasonic(TRIG, ECHO) {}

    void initAll() {
        wiringPiSetup();
        pirFront.init(); pirBack.init(); pirLeft.init(); pirRight.init();
        ultrasonic.init();
        pinMode(MOTOR_L1, OUTPUT); pinMode(MOTOR_L2, OUTPUT);
        pinMode(MOTOR_R1, OUTPUT); pinMode(MOTOR_R2, OUTPUT);
    }

    void loop() {
        while (true) {
            bool front = pirFront.detect();
            bool back = pirBack.detect();
            bool left = pirLeft.detect();
            bool right = pirRight.detect();
            bool obstacle = ultrasonic.detect();

            printStatusBits(front, back, left, right);

            if (front) voice.speak("Motion detected at front");
            else if (back) voice.speak("Motion detected at back");
            else if (left) voice.speak("Motion detected at left");
            else if (right) voice.speak("Motion detected at right");

            if (obstacle) {
                stop();
                voice.speak("Obstacle detected, stopping");
            } else if (front || back || left || right) {
                move(); // move forward
            } else {
                stop();
                voice.speak("No motion, robot stopped");
            }
            delay(1000);
        }
    }
};

int main() {
    MotionController robot;
    robot.initAll();
    robot.loop();
    return 0;
}
